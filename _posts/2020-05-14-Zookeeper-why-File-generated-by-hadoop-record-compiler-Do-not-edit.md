---
author: renfakai
layout: post
title: 原创-zookeeper.jute基础代码生成
date: 2020-05-14
categories: zookeeper
tags: [java，zookeeper]
description: 读源码
---


##  Zookeeper why File generated by hadoop record compiler. Do not edit?



1. Rcc的主方法，需要传递`zookeeper.jute`文件的位置。

```java
 // args = -l c "/Users/renfakai/github/gcc/zookeeper.jute"  生成c语言
 // args = -l c++ "/Users/renfakai/github/gcc/zookeeper.jute"  生成c++
 // args = "/Users/renfakai/github/gcc/zookeeper.jute" 生成Java
 public static void main(String args[]) {
        // 默认语言
        String language = "java";
        ArrayList<String> recFiles = new ArrayList<String>();
        JFile curFile=null;

        for (int i=0; i<args.length; i++) {
            // 如果传参数为其他语言的话这里变更语言
            if ("-l".equalsIgnoreCase(args[i]) ||
                "--language".equalsIgnoreCase(args[i])) {
                language = args[i+1].toLowerCase();
                i++;
            } else {
               // 设置需要解析文件位置
                recFiles.add(args[i]);
            }
        }
        // 支持的语言主要为c++，Java和c
        if (!"c++".equals(language) && !"java".equals(language) && !"c".equals(language)) {
           // 语言不支持不解析
            System.out.println("Cannot recognize language:" + language);
            System.exit(1);
        }
        if (recFiles.size() == 0) {
           // 没有设置文件
            System.out.println("No record files specified. Exiting.");
            System.exit(1);
        }
        for (int i=0; i<recFiles.size(); i++) {
            curFileName = recFiles.get(i);
            File file = new File(curFileName);
            try {
                // 解析文件
                curFile = parseFile(file);
            } catch (FileNotFoundException e) {
                System.out.println("File " + recFiles.get(i) + " Not found.");
                System.exit(1);
            } catch (ParseException e) {
                System.out.println(e.toString());
                System.exit(1);
            }
            System.out.println(recFiles.get(i) + " Parsed Successfully");
            try {
                // 生成代码
                curFile.genCode(language, new File("."));
            } catch (IOException e) {
                System.out.println(e.toString());
                System.exit(1);
            }
        }
    }
```

2. 查看解析文件`curFile = parseFile(file);`，这里会把`zookeeper.jute`解析成`JFile`。

```java
 public static JFile parseFile(File file) throws FileNotFoundException, ParseException {
        // 目录
        curDir = file.getParent();
       // 文件名称
        curFileName = file.getName();
        FileReader reader = new FileReader(file);
        try {
           // 解析文件,然后返回
            Rcc parser = new Rcc(reader);
            recTab = new Hashtable<String, JRecord>();
            return parser.Input();
        } finally {
            try {
               //关闭流
                reader.close();
            } catch (IOException e) {
            }
        }
    }

```

3. 我把生成的类文件代码改成了` curFile.genCode(language, new File("/Users/renfakai/github/gcc/"));`

然后查看`JFile`生成代码，查看这个方法，这里主要是根据语言调用不同的方法。

```java
     public void genCode(String language, File outputDirectory)
            throws IOException {
        if ("c++".equals(language)) {
            CppGenerator gen = new CppGenerator(mName, mInclFiles, mRecords,
                    outputDirectory);
            gen.genCode();
        } else if ("java".equals(language)) {
            // java   private List<JRecord> mRecords; 
            JavaGenerator gen = new JavaGenerator(mName, mInclFiles, mRecords,
                    outputDirectory);
            gen.genCode();
        } else if ("c".equals(language)) {
            CGenerator gen = new CGenerator(mName, mInclFiles, mRecords,
                    outputDirectory);
            gen.genCode();
        } else if ("csharp".equals(language)) {
            CSharpGenerator gen = new CSharpGenerator(mName, mInclFiles, mRecords,
                    outputDirectory);
            gen.genCode();
        } else {
            throw new IOException("Cannnot recognize language:" + language);
        }
    }
```

```java
// 生成代码 
   void genCode() throws IOException {
        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {
            JRecord rec = i.next();
            rec.genJavaCode(outputDirectory);
        }
    }
```

4. 看一下这个迭代里面数据是啥，Debug了一下，看了下数据，如图所示。

![avatar](/img/jfile/JFile-item.png)  

5. 生成代码的源代码。

```java
 public void genJavaCode(File outputDirectory) throws IOException {
        String pkg = getJavaPackage();
        String pkgpath = pkg.replaceAll("\\.", "/");
        File pkgdir = new File(outputDirectory, pkgpath);
        if (!pkgdir.exists()) {
            // create the pkg directory
            if (!pkgdir.mkdirs()) {
                throw new IOException("Cannnot create directory: " + pkgpath);
            }
        } else if (!pkgdir.isDirectory()) {
            throw new IOException(pkgpath + " is not a directory.");
        }
        try (FileWriter jj = new FileWriter(new File(pkgdir, getName() + ".java"))) {
            jj.write("// File generated by hadoop record compiler. Do not edit.\n");
            jj.write("/**\n");
            jj.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
            jj.write("* or more contributor license agreements.  See the NOTICE file\n");
            jj.write("* distributed with this work for additional information\n");
            jj.write("* regarding copyright ownership.  The ASF licenses this file\n");
            jj.write("* to you under the Apache License, Version 2.0 (the\n");
            jj.write("* \"License\"); you may not use this file except in compliance\n");
            jj.write("* with the License.  You may obtain a copy of the License at\n");
            jj.write("*\n");
            jj.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
            jj.write("*\n");
            jj.write("* Unless required by applicable law or agreed to in writing, software\n");
            jj.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
            jj.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
            jj.write("* See the License for the specific language governing permissions and\n");
            jj.write("* limitations under the License.\n");
            jj.write("*/\n");
            jj.write("\n");
            jj.write("package " + getJavaPackage() + ";\n\n");
            jj.write("import org.apache.jute.*;\n");
            jj.write("import org.apache.jute.Record; // JDK14 needs explicit import due to clash with java.lang.Record\n");
            jj.write("import org.apache.yetus.audience.InterfaceAudience;\n");
            jj.write("@InterfaceAudience.Public\n");
            jj.write("public class " + getName() + " implements Record {\n");
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {
                JField jf = i.next();
                jj.write(jf.genJavaDecl());
            }
            jj.write("  public " + getName() + "() {\n");
            jj.write("  }\n");

            jj.write("  public " + getName() + "(\n");
            int fIdx = 0;
            int fLen = mFields.size();
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaConstructorParam(jf.getName()));
                jj.write((fLen - 1 == fIdx) ? "" : ",\n");
            }
            jj.write(") {\n");
            fIdx = 0;
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaConstructorSet(jf.getName()));
            }
            jj.write("  }\n");
            fIdx = 0;
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaGetSet(fIdx));
            }
            jj.write("  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n");
            jj.write("    a_.startRecord(this,tag);\n");
            fIdx = 0;
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaWriteMethodName());
            }
            jj.write("    a_.endRecord(this,tag);\n");
            jj.write("  }\n");

            jj.write("  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n");
            jj.write("    a_.startRecord(tag);\n");
            fIdx = 0;
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaReadMethodName());
            }
            jj.write("    a_.endRecord(tag);\n");
            jj.write("}\n");

            jj.write("  public String toString() {\n");
            jj.write("    try {\n");
            jj.write("      java.io.ByteArrayOutputStream s =\n");
            jj.write("        new java.io.ByteArrayOutputStream();\n");
            jj.write("      ToStringOutputArchive a_ = \n");
            jj.write("        new ToStringOutputArchive(s);\n");
            jj.write("      a_.startRecord(this,\"\");\n");
            fIdx = 0;
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaWriteMethodName());
            }
            jj.write("      a_.endRecord(this,\"\");\n");
            jj.write("      return new String(s.toByteArray(), \"UTF-8\");\n");
            jj.write("    } catch (Throwable ex) {\n");
            jj.write("      ex.printStackTrace();\n");
            jj.write("    }\n");
            jj.write("    return \"ERROR\";\n");
            jj.write("  }\n");

            jj.write("  public void write(java.io.DataOutput out) throws java.io.IOException {\n");
            jj.write("    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n");
            jj.write("    serialize(archive, \"\");\n");
            jj.write("  }\n");

            jj.write("  public void readFields(java.io.DataInput in) throws java.io.IOException {\n");
            jj.write("    BinaryInputArchive archive = new BinaryInputArchive(in);\n");
            jj.write("    deserialize(archive, \"\");\n");
            jj.write("  }\n");

            jj.write("  public int compareTo (Object peer_) throws ClassCastException {\n");
            boolean unimplemented = false;
            for (JField f : mFields) {
                if ((f.getType() instanceof JMap)
                        || (f.getType() instanceof JVector)) {
                    unimplemented = true;
                }
            }
            if (unimplemented) {
                jj.write("    throw new UnsupportedOperationException(\"comparing "
                        + getName() + " is unimplemented\");\n");
            } else {
                jj.write("    if (!(peer_ instanceof " + getName() + ")) {\n");
                jj.write("      throw new ClassCastException(\"Comparing different types of records.\");\n");
                jj.write("    }\n");
                jj.write("    " + getName() + " peer = (" + getName() + ") peer_;\n");
                jj.write("    int ret = 0;\n");
                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                    JField jf = i.next();
                    jj.write(jf.genJavaCompareTo());
                    jj.write("    if (ret != 0) return ret;\n");
                }
                jj.write("     return ret;\n");
            }
            jj.write("  }\n");

            jj.write("  public boolean equals(Object peer_) {\n");
            jj.write("    if (!(peer_ instanceof " + getName() + ")) {\n");
            jj.write("      return false;\n");
            jj.write("    }\n");
            jj.write("    if (peer_ == this) {\n");
            jj.write("      return true;\n");
            jj.write("    }\n");
            jj.write("    " + getName() + " peer = (" + getName() + ") peer_;\n");
            jj.write("    boolean ret = false;\n");
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaEquals());
                jj.write("    if (!ret) return ret;\n");
            }
            jj.write("     return ret;\n");
            jj.write("  }\n");

            jj.write("  public int hashCode() {\n");
            jj.write("    int result = 17;\n");
            jj.write("    int ret;\n");
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                jj.write(jf.genJavaHashCode());
                jj.write("    result = 37*result + ret;\n");
            }
            jj.write("    return result;\n");
            jj.write("  }\n");
            jj.write("  public static String signature() {\n");
            jj.write("    return \"" + getSignature() + "\";\n");
            jj.write("  }\n");

            jj.write("}\n");
        }
    }

```

6. 一共生成了下面这么多类。

```java
.
├── org
│   └── apache
│       └── zookeeper
│           ├── data
│           │   ├── ACL.java
│           │   ├── Id.java
│           │   ├── Stat.java
│           │   └── StatPersisted.java
│           ├── proto
│           │   ├── AddWatchRequest.java
│           │   ├── AuthPacket.java
│           │   ├── CheckVersionRequest.java
│           │   ├── CheckWatchesRequest.java
│           │   ├── ConnectRequest.java
│           │   ├── ConnectResponse.java
│           │   ├── Create2Response.java
│           │   ├── CreateRequest.java
│           │   ├── CreateResponse.java
│           │   ├── CreateTTLRequest.java
│           │   ├── DeleteRequest.java
│           │   ├── ErrorResponse.java
│           │   ├── ExistsRequest.java
│           │   ├── ExistsResponse.java
│           │   ├── GetACLRequest.java
│           │   ├── GetACLResponse.java
│           │   ├── GetAllChildrenNumberRequest.java
│           │   ├── GetAllChildrenNumberResponse.java
│           │   ├── GetChildren2Request.java
│           │   ├── GetChildren2Response.java
│           │   ├── GetChildrenRequest.java
│           │   ├── GetChildrenResponse.java
│           │   ├── GetDataRequest.java
│           │   ├── GetDataResponse.java
│           │   ├── GetEphemeralsRequest.java
│           │   ├── GetEphemeralsResponse.java
│           │   ├── GetMaxChildrenRequest.java
│           │   ├── GetMaxChildrenResponse.java
│           │   ├── GetSASLRequest.java
│           │   ├── MultiHeader.java
│           │   ├── ReconfigRequest.java
│           │   ├── RemoveWatchesRequest.java
│           │   ├── ReplyHeader.java
│           │   ├── RequestHeader.java
│           │   ├── SetACLRequest.java
│           │   ├── SetACLResponse.java
│           │   ├── SetDataRequest.java
│           │   ├── SetDataResponse.java
│           │   ├── SetMaxChildrenRequest.java
│           │   ├── SetSASLRequest.java
│           │   ├── SetSASLResponse.java
│           │   ├── SetWatches.java
│           │   ├── SetWatches2.java
│           │   ├── SyncRequest.java
│           │   ├── SyncResponse.java
│           │   └── WatcherEvent.java
│           ├── server
│           │   ├── persistence
│           │   │   └── FileHeader.java
│           │   └── quorum
│           │       ├── LearnerInfo.java
│           │       ├── QuorumAuthPacket.java
│           │       └── QuorumPacket.java
│           └── txn
│               ├── CheckVersionTxn.java
│               ├── CloseSessionTxn.java
│               ├── CreateContainerTxn.java
│               ├── CreateSessionTxn.java
│               ├── CreateTTLTxn.java
│               ├── CreateTxn.java
│               ├── CreateTxnV0.java
│               ├── DeleteTxn.java
│               ├── ErrorTxn.java
│               ├── MultiTxn.java
│               ├── SetACLTxn.java
│               ├── SetDataTxn.java
│               ├── SetMaxChildrenTxn.java
│               ├── Txn.java
│               ├── TxnDigest.java
│               └── TxnHeader.java
└── zookeeper.jute

9 directories, 71 files	
```

7. 挑选两个类进行查看

```java
// File generated by hadoop record compiler. Do not edit.
/**
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package org.apache.zookeeper.data;

import org.apache.jute.*;
import org.apache.jute.Record; // JDK14 needs explicit import due to clash with java.lang.Record
import org.apache.yetus.audience.InterfaceAudience;
@InterfaceAudience.Public
public class ACL implements Record {
  private int perms;
  private org.apache.zookeeper.data.Id id;
  public ACL() {
  }
  public ACL(
        int perms,
        org.apache.zookeeper.data.Id id) {
    this.perms=perms;
    this.id=id;
  }
  public int getPerms() {
    return perms;
  }
  public void setPerms(int m_) {
    perms=m_;
  }
  public org.apache.zookeeper.data.Id getId() {
    return id;
  }
  public void setId(org.apache.zookeeper.data.Id m_) {
    id=m_;
  }
  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(this,tag);
    a_.writeInt(perms,"perms");
    a_.writeRecord(id,"id");
    a_.endRecord(this,tag);
  }
  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(tag);
    perms=a_.readInt("perms");
    id= new org.apache.zookeeper.data.Id();
    a_.readRecord(id,"id");
    a_.endRecord(tag);
}
  public String toString() {
    try {
      java.io.ByteArrayOutputStream s =
        new java.io.ByteArrayOutputStream();
      ToStringOutputArchive a_ = 
        new ToStringOutputArchive(s);
      a_.startRecord(this,"");
    a_.writeInt(perms,"perms");
    a_.writeRecord(id,"id");
      a_.endRecord(this,"");
      return new String(s.toByteArray(), "UTF-8");
    } catch (Throwable ex) {
      ex.printStackTrace();
    }
    return "ERROR";
  }
  public void write(java.io.DataOutput out) throws java.io.IOException {
    BinaryOutputArchive archive = new BinaryOutputArchive(out);
    serialize(archive, "");
  }
  public void readFields(java.io.DataInput in) throws java.io.IOException {
    BinaryInputArchive archive = new BinaryInputArchive(in);
    deserialize(archive, "");
  }
  public int compareTo (Object peer_) throws ClassCastException {
    if (!(peer_ instanceof ACL)) {
      throw new ClassCastException("Comparing different types of records.");
    }
    ACL peer = (ACL) peer_;
    int ret = 0;
    ret = (perms == peer.perms)? 0 :((perms<peer.perms)?-1:1);
    if (ret != 0) return ret;
    ret = id.compareTo(peer.id);
    if (ret != 0) return ret;
     return ret;
  }
  public boolean equals(Object peer_) {
    if (!(peer_ instanceof ACL)) {
      return false;
    }
    if (peer_ == this) {
      return true;
    }
    ACL peer = (ACL) peer_;
    boolean ret = false;
    ret = (perms==peer.perms);
    if (!ret) return ret;
    ret = id.equals(peer.id);
    if (!ret) return ret;
     return ret;
  }
  public int hashCode() {
    int result = 17;
    int ret;
    ret = (int)perms;
    result = 37*result + ret;
    ret = id.hashCode();
    result = 37*result + ret;
    return result;
  }
  public static String signature() {
    return "LACL(iLId(ss))";
  }
}

```

```
// File generated by hadoop record compiler. Do not edit.
/**
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package org.apache.zookeeper.data;

import org.apache.jute.*;
import org.apache.jute.Record; // JDK14 needs explicit import due to clash with java.lang.Record
import org.apache.yetus.audience.InterfaceAudience;
@InterfaceAudience.Public
public class Id implements Record {
  private String scheme;
  private String id;
  public Id() {
  }
  public Id(
        String scheme,
        String id) {
    this.scheme=scheme;
    this.id=id;
  }
  public String getScheme() {
    return scheme;
  }
  public void setScheme(String m_) {
    scheme=m_;
  }
  public String getId() {
    return id;
  }
  public void setId(String m_) {
    id=m_;
  }
  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(this,tag);
    a_.writeString(scheme,"scheme");
    a_.writeString(id,"id");
    a_.endRecord(this,tag);
  }
  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {
    a_.startRecord(tag);
    scheme=a_.readString("scheme");
    id=a_.readString("id");
    a_.endRecord(tag);
}
  public String toString() {
    try {
      java.io.ByteArrayOutputStream s =
        new java.io.ByteArrayOutputStream();
      ToStringOutputArchive a_ = 
        new ToStringOutputArchive(s);
      a_.startRecord(this,"");
    a_.writeString(scheme,"scheme");
    a_.writeString(id,"id");
      a_.endRecord(this,"");
      return new String(s.toByteArray(), "UTF-8");
    } catch (Throwable ex) {
      ex.printStackTrace();
    }
    return "ERROR";
  }
  public void write(java.io.DataOutput out) throws java.io.IOException {
    BinaryOutputArchive archive = new BinaryOutputArchive(out);
    serialize(archive, "");
  }
  public void readFields(java.io.DataInput in) throws java.io.IOException {
    BinaryInputArchive archive = new BinaryInputArchive(in);
    deserialize(archive, "");
  }
  public int compareTo (Object peer_) throws ClassCastException {
    if (!(peer_ instanceof Id)) {
      throw new ClassCastException("Comparing different types of records.");
    }
    Id peer = (Id) peer_;
    int ret = 0;
    ret = scheme.compareTo(peer.scheme);
    if (ret != 0) return ret;
    ret = id.compareTo(peer.id);
    if (ret != 0) return ret;
     return ret;
  }
  public boolean equals(Object peer_) {
    if (!(peer_ instanceof Id)) {
      return false;
    }
    if (peer_ == this) {
      return true;
    }
    Id peer = (Id) peer_;
    boolean ret = false;
    ret = scheme.equals(peer.scheme);
    if (!ret) return ret;
    ret = id.equals(peer.id);
    if (!ret) return ret;
     return ret;
  }
  public int hashCode() {
    int result = 17;
    int ret;
    ret = scheme.hashCode();
    result = 37*result + ret;
    ret = id.hashCode();
    result = 37*result + ret;
    return result;
  }
  public static String signature() {
    return "LId(ss)";
  }
}

```

总结：因为基础代码通用，所以使用这种技术来生成Java类吧。

