---
author: renfakai
layout: post
title: 原创-字节码改造中金支付
date: 2020-05-05
categories: 支付
tags: [java，支付]
description: 账户设计
---

## 字节码改造中金支付
tips:本是一个Crud.Boy，为了工作偷懒，思想上不偷懒，分析了中金源码并进行改造。

背景:  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速简单的接入三方支付，仅展示中金支付。

原因:
在接入中金支付时候，发现中金支付给出的源码不支持多商户(`TxBaseRequest.postProcess()  byte[] signature = SignatureFactory.getSigner().sign(data); `)，这一点与支付中心的思想相违背。

方案:
* 将源码重新梳理一遍，重新编写(耗时耗力)
* 让中金给一套更改过的源码(沟通过，反正就是不给)
* 使用字节码将代码进行变更，在运行时进行替换。(Java Agent维护系数大，最后使用的是Byte Buddy)


解决问题:
1. 项目导入包结构如下:

```JAVA
.
├── InstitutionTools-v1.0.0.1.jar
└── cpcn-payment-api-2.4.5.3.jar

0 directories, 2 files

```  

2. pom导入中金的包:  

```JAVA
  <!-- cpcn  local lib-->
        <dependency>
            <groupId>cpcn.institution</groupId>
            <artifactId>API</artifactId>
            <version>2.4.1.5</version>
            <scope>system</scope>
            <systemPath>${basedir}/src/lib/cpcn-payment-api-2.4.5.3.jar</systemPath>
        </dependency>
        <dependency>
            <groupId>cpcn.payment</groupId>
            <artifactId>InstitutionTools</artifactId>
            <version>v1.0.0.1</version>
            <scope>system</scope>
            <systemPath>${basedir}/src/lib/InstitutionTools-v1.0.0.1.jar</systemPath>
        </dependency>
```


3. 选择了使用更改字节码，让字节码在运行时进行替换,值得注意的是`Unfortunately, redefining loaded classes is limited to replacing method bodies. No members may be added or removed, 
and no types or signatures may change when redefining a class.`这一段出自于[Easily Create Java Agents with Byte Buddy](https://www.infoq.com/articles/Easily-Create-Java-Agents-with-ByteBuddy/)
所以我们要解决的问题就是将`TxBaseRequest.postProcess()  byte[] signature = SignatureFactory.getSigner().sign(data); `进行替换，由于上面的规则，我们要怎么处理呢？
由于不能变更参数和Filed，只能从ThreadLocal(线程安全)上面想办法了，先使用享元模式创建一个容器，来存储多商户的加密SignatureFactory，然后需要运行的TxBaseRequest的代码如下:  
   
```java

public abstract class TxBaseRequestRedefine {

    protected String txCode;
    protected String requestPlainText;
    protected String requestMessage;
    protected String requestSignature;

    public TxBaseRequestRedefine() {
    }

    public String getRequestPlainText() {
        return this.requestPlainText;
    }

    public String getRequestMessage() {
        return this.requestMessage;
    }

    public String getRequestSignature() {
        return this.requestSignature;
    }

    public abstract void process() throws Exception;

    protected void postProcess(Document document) throws Exception {
        this.requestPlainText = XmlUtil.createPrettyFormat(document).trim();
        byte[] data = this.requestPlainText.getBytes(StandardCharsets.UTF_8);
        this.requestMessage = new String(Base64.encode(data));
        byte[] signature = CpcnSignatureFactoryContext.getSignatureFactoryReplace(MerchantContext.get()).getSigner().sign(data);
        this.requestSignature = StringUtil.bytes2hex(signature);
    }
}

```

4. 如何让这一段代码在运行时候进行替换呢？在SpringBoot启动时候手动调用` CpcnRedefine.getInstance().redefine();`。 

```Java

public class CpcnRedefine {

    private CpcnRedefine() {
        ByteBuddyAgent.install();
    }

    private volatile static CpcnRedefine instance;

    public static CpcnRedefine getInstance() {
        if (Objects.isNull(instance)) {
            synchronized (CpcnRedefine.class) {
                if (Objects.isNull(instance)) {
                    instance = new CpcnRedefine();
                }
            }
        }
        return instance;
    }

      
    private void txBaseRequestReplace() {
        new ByteBuddy()
                .redefine(TxBaseRequestRedefine.class)
                .name(TxBaseRequest.class.getName())
                .make()
                // 这里查找ClassLoader是因为双亲委派原则，大家可以看深入理解虚拟机一书
                .load(TxBaseRequest.class.getClassLoader(), ClassReloadingStrategy.fromInstalledAgent());

    }

    public void redefine() {
        this.txBaseRequestReplace();
    }
}

```

5. 下面我们来讲这一句话` byte[] signature = CpcnSignatureFactoryContext.getSignatureFactoryReplace(MerchantContext.get()).getSigner().sign(data);`
CpcnSignatureFactoryContext其实就是一个享元模式的容器，很像ApplicationContext，可以从中根据Name获取到某个Bean。然后来看下MerchantContext，
这个主要是一个ThreadLocal，用来传递参数，来解决替换类参数和Filed不可替换问题的。   


```Java

public class CpcnSignatureFactoryContext {

    /**
     * key商户号
     */
    private static final Map<String, SignatureFactoryReplace> signContainer = new ConcurrentHashMap<>();

    private CpcnSignatureFactoryContext() {
    }

    public static void putSignatureFactoryReplace(String key, SignatureFactoryReplace value) {
        signContainer.put(key, value);
    }

    public static SignatureFactoryReplace getSignatureFactoryReplace(String key) {
        return signContainer.get(key);
    }
}


public final class MerchantContext {

    private static final ThreadLocal<String> threadLocal = new ThreadLocal<>();

    public static String get() {
        return threadLocal.get();
    }

    public static void put(String t) {
        threadLocal.set(t);
    }

    public static void remove() {
        threadLocal.remove();
    }

}

```

6. 这个时候你肯定很想知道如何将配置文件变成SignatureFactoryReplace，大家可以参考`PaymentSignatureFactoryEnvironmentInit`，由于公司机密原因，
这里我有了改造，这里不适合测试和生产pfx配置，所以上面的代码才是抛转引玉，PaymentSignatureFactoryEnvironmentInit代码如下:   

```Java
/**
 * 中金证书加载,将证书放到容器中
 *
 * @author renfakai
 */
@Slf4j
@Component
public class PaymentSignatureFactoryEnvironmentInit {
    /**
     * 加密方式
     */
    private static final String CPCN_SIGNATURE_ALGORITHM = "cpcn.signature.algorithm";
    /**
     * 密码
     */
    private static final String CPCN_PASSWORD = ".cpcn.password";
    /**
     * 商户号
     */
    private static final String CPCN_MERCHANT = ".cpcn.merchant";

    @PostConstruct
    public void init() {
        try {
            String paymentConfigPath = new ClassPathResource("conf/cpcn/").getURL().getPath();
            File file = new File(paymentConfigPath);
            File[] allFile = file.listFiles();
            Assert.notNull(allFile, "中金配置文件不能为空");
            for (File item : allFile) {
                if (!item.isDirectory()) {
                    continue;
                }
                this.handler(item);
            }
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage());
        }
    }


    public void handler(File file) {
        try {
            String name = file.getName();
            String myKeystorePassword = Configuration.get(name + CPCN_PASSWORD);
            String algorithm = Configuration.get(CPCN_SIGNATURE_ALGORITHM);
            String merchant = Configuration.get(name + CPCN_MERCHANT);
            File[] allFile = file.listFiles();

            Assert.notNull(allFile, "中金证书不能为空");
            SignatureFactoryReplace signatureFactoryReplace = new SignatureFactoryReplace();
            for (File innerFile : allFile) {
                if (innerFile.getName().endsWith("pfx")) {
                    Signer signer = new PfxSigner(innerFile.getAbsolutePath(), myKeystorePassword, algorithm);
                    signatureFactoryReplace.setSigner(signer);
                }
            }
            CpcnSignatureFactoryContext.putSignatureFactoryReplace(merchant, signatureFactoryReplace);
        } catch (Exception e) {
            log.error("加载中金证书出现错误", e);
            throw new RuntimeException("加载中金证书出现错误");
        }
    }
}

```
7. 这样的话，基本所有源码级别的东西都改造完了，在产生`TxxxxRequest`时候调用`postProcess(Document document)`也就不会出现加密什么异常了，剩下的就是中金代码使用，
编写一个中金接口管理器和中金的发送抽象类，代码为:   
    
```Java

// 中金接口管理器
public final class PolicyManager {

    private static final Map<String, AbstractCpcnPayService> CONTAINER = new ConcurrentHashMap<>();


    public static boolean register(String key, AbstractCpcnPayService service) {
        return CONTAINER.put(key, service) != null;
    }

    public static AbstractCpcnPayService getPolicy(String channel) {
        AbstractCpcnPayService policyService = CONTAINER.get(channel);
        return policyService;
    }
}


// 中金的发送抽象类
public abstract class AbstractCpcnPayService implements InitializingBean {


    protected Logger logger = LoggerFactory.getLogger(getClass());

    /**
     * 统一处理工具
     *
     * @param request 请求
     * @return 结果
     */
    public TxBaseResponse handler(TxBaseRequest request) {
        TxBaseResponse response = null;
        logger.info("请求中金请求参数为{}", JSONObject.toJSONString(request));
        String[] resp = this.send(request.getRequestMessage(), request.getRequestSignature(), request.getRequestPlainText());

        if (ObjectUtils.isEmpty(resp) || resp.length <= 1) {
            throw new IllegalArgumentException("返回数据不符合格式");
        }
        CpcnHandlerType cpcnHandlerType = AnnotationUtils.findAnnotation(this.getClass(), CpcnHandlerType.class);
        // check
        Assert.notNull(cpcnHandlerType, "HandlerType获取类型为空");
        Class<? extends TxBaseResponse> responseType = cpcnHandlerType.response();
        Assert.notNull(responseType, "responseType获取类型为空");
        try {
            Constructor<? extends TxBaseResponse> constructor = responseType.getConstructor(String.class, String.class);
            response = constructor.newInstance(resp[0], resp[1]);
            logger.info("请求中金返回参数为{}", JSONObject.toJSONString(response));
        } catch (Exception e) {
            logger.error("处理数据出现错误", e);
        }

        Assert.notNull(response, "获取数据为空");
        // Assert.isTrue(Objects.equals("2000", response.getCode()), response.getMessage());
        return response;
    }


    /**
     * 请求中金接口
     *
     * @param requestMessage   请求的信息
     * @param requestSignature 签名信息
     * @param xml              组成的xml
     * @return 结果
     */
    protected String[] send(String requestMessage, String requestSignature, String xml) {

        TxMessenger txMessenger = new TxMessenger();
        String url = getRequestUrl();
        logger.info(String.format("请求中金数据:[%s],xml为:[%s],url:[%s]", requestMessage, xml, url));
        String[] result = null;
        try {
            result = txMessenger.send(requestMessage, requestSignature, url);
        } catch (Exception e) {
            logger.error(String.format("请求中金出现错误,请求数据为%s", xml), e);
        }
        logger.info(String.format("请求中金返回原始数据为:[%s]", Arrays.toString(result)));
        return result;
    }


    protected String getRequestUrl() {
        return Configuration.get(CpcnConstant.CPCN_REQUEST_URL);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        CpcnHandlerType annotation = this.getClass().getAnnotation(CpcnHandlerType.class);
        if (Objects.nonNull(annotation)) {
            PolicyManager.register(annotation.value().getCode(), this);
        }
    }
}


```

8. 由于Java的泛型在前端编译期间会擦除(可参考深入理解虚拟机)，所以我个人更喜欢使用注解替换泛型，然后编写注解和枚举及实现类:


```Java
//注解

@Component
@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CpcnHandlerType {

    @NonNull
    CpcnRequestType value();

    @NonNull
    Class<? extends TxBaseResponse> response();
}

//枚举
@Getter
@AllArgsConstructor
public enum CpcnRequestType {

    /**
     * 4530-机构支付账户单笔代付
     */
    TX_4510_REQUEST("4510", "4510-机构支付账户余额查询"),

    /**
     * 4530-机构支付账户单笔代付
     */
    TX_4530_REQUEST("4530", "4530-机构支付账户单笔代付"),

    /**
     * 4532-机构支付账户单笔代付查询
     */
    TX_4532_REQUEST("4532", "4532-机构支付账户单笔代付查询"),

    /**
     * 2820-支付查询
     */
    TX_2820_REQUEST("2820", "2820-支付查询"),


    /**
     * 2841-订单关闭
     */
    TX_2841_REQUEST("2841", "2841-订单关闭"),

    /**
     * 2811-扫码支付
     */
    TX_2811_REQUEST("2811", "2811-扫码支付"),

    /**
     * 2813-公众号支付
     */
    TX_2813_REQUEST("2813", "2813-公众号支付"),

    /**
     * 2814-APP支付
     */
    TX_2814_REQUEST("2814", "2814-APP支付"),

    /**
     * 2531-建立绑定关系(发送验证短信)
     */
    TX_2531_REQUEST("2531", "2531-建立绑定关系"),

    /**
     * 2532-建立绑定关系(验证并绑定)
     */
    TX_2532_REQUEST("2532", "2532-建立绑定关系"),

    /**
     * 2532-建立绑定关系(验证并绑定)
     */
    TX_2340_REQUEST("2340", "2340-四要素验证"),

    /**
     * 2532-建立绑定关系(验证并绑定)
     */
    TX_2320_REQUEST("2320", "2320-身份验证"),


    /**
     * 2911-电子回单下载
     */
    TX_2911_REQUEST("2911", "2911-电子回单下载"),

    /**
     * 2011-单笔代扣请求
     */
    TX_2011_REQUEST("2011", "2011-单笔代扣请求"),

    /**
     * 2020-单笔代扣交易查询
     */
    TX_2020_REQUEST("2020", "2020-单笔代扣交易查询"),

    /**
     * 1620-批量代收查询
     */
    TX_1620_REQUEST("1620", "1620-批量代收查询"),
    /**
     * 1610-批量代收
     */
    TX_1610_REQUEST("1610", "1610-批量代收"),

    ;
    /**
     * code
     */
    private final String code;

    /**
     * 形容
     */
    private final String desc;
}

// 实现类 
@CpcnHandlerType(value = CpcnRequestType.TX_1610_REQUEST, response = Tx1610Response.class)
public class Tx1610RequestPolicy extends AbstractCpcnPayService {
}

```

10. 然后你就可以在你的Service层编写业务代码了，代码如下：  

```java
             // 1.创建交易请求对象
            Tx2210Request tx2210Request = new Tx2210Request();
            tx2210Request.setInstitutionID(institutionID);
            tx2210Request.setOrderNo(orderNo);
            tx2210Request.setAmount(amount);
            tx2210Request.setPayerName(payerName);
            tx2210Request.setUsage(usage);
            tx2210Request.setRemark(remark);
            tx2210Request.setSettlementFlag(settlementFlag);

            // 2.设置商户号
            MerchantContext.put(institutionID);


            // 3.执行报文处理
            tx2210Request.process();

           
```

## 总结
优点:商户号可能是你根据路由进行路由出来的，也可能是写死的，无论是哪一种，都支持数据驱动业务。
缺点:tx2210Request.process()前需要手动将商户号写入到MerchantContext(也就是 2.设置商户号)。
tips:可以使用Aop或者反射在构造1之前将商户号设置到MerchantContext里面。


